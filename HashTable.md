> 键值对

【例】

通讯录：键是人名，值是电话号码。



衣柜，第一格放内衣，第二格放T恤，第三格放袜子。第几格，或者说抽屉索引就是键，与其对应的放置的衣物种类就是值。



小结：键起到索引作用，值是与键对应的数据。这样组织有对应关系的二元组数据，可以通过键来高效查找。



> 哈希表

存储键值对的一种数据结构。



> 为什么要提出哈希表

提高查找效率。

想象一下这种情况：通讯录有十万个联系人条目，我们要找到需要的某个联系人。

是不是需要挨个核对名字，效率很低。这是一种典型的遍历查找方式，时间复杂度最差为`O(n)`。



> 哈希表的查找优化思想

给出一个数据结构，每一个条目分为索引和值。索引是通过键值对的键经过哈希函数计算出来的。最终达到一种理想情况：每一个键值对的键映射完只对应唯一的一个索引。这样就可以直接通过数组索引访问数组中的数据也就是键值对的值。而数组通过索引访问的操作，时间复杂度为`O(1)`，这样就优化了查找效率。



还是回到通讯录的场景，哈希函数为：去每个字母对应的值（a-z 对应 0~25）求和。

例如：

Ada：0+3+0 = 3

Bob：1+14+1 = 16

我们取哈希表的大小为 18。有一种特殊情况是：

Tim：19+8+12=39 > 18，进行取余操作，39 % 18  =  3

这样问题又来了，哈希值与 Ada 相同，这就造成了哈希冲突。



> 哈希冲突

解决哈希冲突的思路：

1. 发现该索引已不空闲，即已存储值，检查下一个索引位置一旦为空就存入。如果找到最后一个位置也不空，跳到第一个索引位置继续找；
2. 设计每个索引对应一个数组或一个链表而不是单一的存储位置，可以存储多个对象，即使哈希值一样也可以将值存储同一个索引下；
3. 增加表的大小，可以大大减小冲突几率。



* 开放定址法

    1. 线性探测法：被占用后，步长为 1 向后寻找
    2. 二次探测法：被占用后，步长为 2 向后寻找
    3. 伪随机探测法：被占用后，随机出一个数组

* 拉链法

    在冲突处维护一个链表，将所有冲突元素放入该链表





> 哈希函数

好的哈希函数可以大大减少冲突概率，在有限表大小（桶多少）情况下，尽可能的让键值对均匀分布在不同表的位置上（不同桶中）

最坏结果：全部放入一个桶中，这样就和数组查找没区别。



> 自己实现哈希表





> C++中哈希表的实现





> 哈希表的使用案例

1. 是否出现过
2. 出现次数



> 哈希表的思想

哈希表的思想是将无序键值对数据转换为可以一个有序“数组”，这个数组的索引是利用键通过哈希函数计算得到的哈希值；数组元素是键值对中键对应的值。

核心：**从通过遍历键来查找，转化为数组下标访问**。



> 数据结构的选择



|               | 元素类型 | 底层实现 | 是否有序 | 更改键值 | 元素重复 | 查询效率 | 增删效率 |
| ------------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| set           | key      | 红黑树   | 是       | 否       | 否       | O(logN)  | O(logN)  |
| map           | pair     | 红黑树   | 是       | 否       | 否       | O(logN)  | O(logN)  |
| unordered_set |          | 哈希表   | 否       |          |          | O(1)     | O(1)     |
| unordered_map |          | 哈希表   | 否       | 否       |          | O(1)     | O(1)     |

* set 中元素会根据键自动排序（因为红黑树实现），不允许有重复键，不允许修改键，因为会导致红黑树崩溃
* map 中元素会根据键自动排序（因为红黑树实现），不允许元素有相同键





## Set

**set** 是 C++ 关联容器的一种。不同于 **map** 中的元素是以键值对（**key-value**）来组织的（关键字作为索引），**set** 中的元素仅仅是关键字（**key**），索引时也仅需关注关键字即可。

**set** 支持高效查找，底层实现基于**红黑树**，查找的时间复杂度是：**O(logn)**。

**set** 一共分两类：

* 元素（关键字）**是否重复**——包含在头文件 *`<set>`*中
    1. **`set`**
    2. **`multiset`**
* 元素（关键字）**是否无序**——包含在头文件 *`<unordered_set>`*中
    1. **`unordered_set`**
    2. **`unordered_multiset`**



### 创建 set

1. 创建一个空 set ，之后再逐个添加元素：

    ```c++
    #include <set>
    
    std::set<char> s1;

2. 创建 set 的同时对 set 进行值初始化：

    ```c++
    #include <set>
    
    std::set<string> s2 = {"cat","doig"};
    ```

3. 创建 set 的同时利用一个已有 set 进行拷贝初始化：

    ```c++
    #include <set>
    
    std::set<string> s3(s2);    // s3 = {"cat","dog"};



### 添加元素：insert( )

利用 `insert()`函数添加元素，会对元素自动排序

```c++
#include <set>
std::set<int> val = {3,0,1};   // 自动排序为：{0,1,3}
s.insert(2);                   // {0,1,2,3}
s.insert(5);                   // {0,1,2,3,5}
```



### 删除元素：erase( )

```c++
s.erase(3);                    // {0,1,2,5}
```



### 查找元素：find( )

```c++
auto i = s.find(1);
if(i != s.end())
    s.erase(*i);               // {0,2,5}
else
    cout<<"Cannot find the target"<<endl
```
