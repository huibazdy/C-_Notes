# 一、Unix I/O

> **常见 Unix I/O**

* ***打开文件***

    应用程序通过要求内核来来打开响应文件，借此访问 I/O 设备，内核返回一个非负整数，也就是文件描述符。后续对文件的所有操作都基于这个文件标识，对于应用程序来说，只需要这个 **fd** 就可以。

* ***改变文件打开位置***

    对于一个打开的文件，内核记录一个位置值 **k**（从文件开头起始的字节偏移量），期初是 0。

* ***读写文件***

    读，意味着从文件位置 k 开始复制 n 个字节到内存。如果 k 大于等于文件大小 m 时，执行读会触发 EOF 条件，应用程序可以检测到 EOF （注意：文件结尾是不存在“EOF”符号的）。

    写，就是从内存复制 n 个字节到一个文件，从文件位置 k 开始，最后更新 k 值。

* ***关闭文件***

    应用程序访问完文件后，通知内核关闭文件，内核的响应是释放打开文件时创建的数据结构，并将 fd 恢复到可用的 fd 池子中。



## open( )



```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(char* filename, int flags, mode_t mode);
```



open 函数的作用是将 **filename** 转换为一个文件描述符 **fd** 并返回。返回的 fd 总是在进程中没有被打开的 fd 的最小值。

【**参数列表**】

* **`flags`**

    向内核指明进程如何访问这个文件，最常见的访问方式如下：

    * **O_RDONLY**：只读
    * **O_WRONLY**：只写
    * **O_RDWR**：可读可写

    除开这三种还有一些额外提示，此处暂不讨论。

* **`mode`**

    指定新文件的访问权限



## close( )



```c
#include <unistd.h>

int close(int fd);
```



关闭一个已关闭的 fd 会出错。



## read( )

```c
#include <unistd.h>

ssize_t read(int fd, void* buf, size_t n);
```

从当前文件 fd 的位置（内核有记录，即：k）复制 n 个字节的数据到内存的 buf 位置。

正常情况下返回实际传送的字节数，但有两种异常返回情况：

* 发生错误，返回 -1
* 拷贝字节数超出文件位置到结尾的字节数，则返回 0，代表 EOF 。

> **为什么返回值是 ssize_t 类型？**
>
> 因为在 **x86-64** 系统中， **size_t** 被定义为 **unsigned long**（无符号），而 **ssize_t** 被定义为 **long**（有符号），因为有异常返回情况可能是 **-1** ，所以需要定义返回类型为有符号的 **ssize_t** 类型。

## write( )

```c
#include <unistd.h>

ssize_t write(int fd, const void* buf, size_t n);
```

从内存的 buf 位置拷贝 n 字节的数据到文件 fd 中去。

通过 `lseek()`函数能显式地修改当前文件位置。



# 二、RIO

**RIO**（**Robust I/O，健壮的 I/O 包**），它会自动处理读取文件不足的情况（上节中的 EOF 情况）。它提供方便、健壮、高效的 I/O ，主要通过两类函数实现：

* **无缓冲的 I/O 函数**

    这些函数直接在内存和文件之间传递数据，无应用级缓冲。对二进制数据的***网络读写***很重要。

* **带缓冲的 I/O 函数**

    这类函数允许从文件中读取文本行和二进制数据。这些文件数据内容缓存在应用级缓冲区内。类似于为`printf`这样的标准 I/O 函数提供的缓冲区。它们是线程安全的。

