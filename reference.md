一般说的术语引用（reference）未作特别说明，指的是左值引用（lvalue reference）。C++11 引入了右值引用（rvalue reference），主要用于内置类。

引用就是为对象起了个新名字，通过符号`&d`来定义引用类型，其中`d`是声明的变量名（也就是新名字）。

```c++
...
    int val = 3;           
	int &ref1 = val;  // 定义引用 ref1 指向 val，或者说为 val 取了一个新名字 ref1
	int &ref2;        // 会报错，引用变量必须初始化
...
```

定义引用时，会把引用和它的初始值对象**绑定（bind）**，而不是将初始值拷贝给引用。



因为绑定，所以引用无法再绑定到另一个对象上，因此引用必须**初始化**（有一个最初接纳它的对象，**至死不渝**）。



定义引用后，对其进行的所有操作都是在与之绑定的对象上进行的。

```c++
...
    ref1 = 10;       // 将 10 赋给 ref1 指向的对象 val（用其他对象赋值给引用）
	int n = ref1;    // 将 val 的值赋给 n（引用赋值给其他对象）
...
```



> 以引用作为初值

以引用作为初值，也是绑定到最初的对象上去。

``` c++
...
    int &ref3 = ref1;  // ref3 也绑定到 val 上，此时 ref3 的值也是绑定到 val 上，为 10	
...
```



> 常量引用

把引用绑定到 const 对象上，称之为常量引用。与普通引用不同，常量引用不能修改它绑定的对象。

```c++
...
    const int m = 100;
	const int &r1 = m;   // 声明常量引用
	r1 = 5;              // 错误，试图用常量引用修改常量
	int &r2 = m;         // 错误，试图让非常量引用指向常量
...
```



常量引用可以绑定到非常量对象、字面值、一般表达式

```c++
...
    int  i = 10;
	const int &r3 = i;
	const int &r4 = 3;
	const int &r5 = r1* 2;
...
```



> **引用的常见用法**

### 一、作为函数参数

【**例**】

以下三种参数传递方式都是传递 `Cls`类的对象到不同函数，函数体都是对类的成员函数`m_fun()`调用：

```c++
// 传递对象的指针
void func1(Cls* ptr_obj) {ptr_obj->m_func();}
// 传递对象本身
void func2(Cls obj) {obj.m_func();}
// 传递对象的引用
void fun3(Cls& obj) {obj.m_func();}
```

对三种不同传参形式函数的调用如下：

```c++
func1(&obj1);  //传指针
func2(obj2);   //传值
func3(obj3);   //传引用
```

【<span style="color:red">**注**</span>】

从上面可以看出，在函数声明时不能存在同名函数的传值和传引用两种形式，否则在调用时编译器不知道该调用哪个函数，会造成歧义（**Ambiguity**）。例如：

```c++
double imag(const double im) {...}
double imag(const double& im) {...}
```

对两个函数的调用形式都是：

```c++
imag(im);
```



### 二、作为函数返回类型



