# 智能指针

内存的划分：

* **静态内存**
    * 局部 static 对象
    * 类的 static 数据成员
    * 全局变量：定义在所有函数之外的变量
* **栈内存**
    * 函数内的非 static 变量

> **以上两个内存区域的变量由编译器自动创建和销毁。**
>
> 关于静态内存分配（参考：《程序员的自我修养：链接、装载与库》）
>
> 1. BSS 段：**未初始化**的全局变量和局部 static 变量
> 2. DATA 段：**已初始化**的全局变量和局部 static 变量



除了以上两个内存区域，每个程序还有一个***内存池***，这部分内存空间称为***堆***（heap）。

* **堆**
    * 存储动态分配对象

> **动态对象是由程序控制生存期、在程序运行时分配的对象。不再使用时，需要显示销毁。**





动态内存的管理方式是用一对运算符来完成的，分别是：**`new`** 和 **`delete`** 。

* **new**

    为动态对象分配空间，并返回一个指向该地址的指针。

* **delete**

    接受一个指向动态对象的指针，销毁该对象，并释放相关内存。





在复杂且大型的程序中，确保正确的时间释放内存极其困难。忘记释放会引起**内存泄漏**，还有引用该内存的情况下就释放会产生引用非法内存的指针。





为了更安全地使用动态内存，引入**智能指针**来管理动态对象。智能指针的行为类似于常规指针，区别是它们负责自动释放指向的对象。



* **`shared_ptr`**

    允许多个指针指向同一个对象

* **`unique_ptr`**

    独占指向的对象

* **`weak_ptr`**

    一种伴随类，是一种弱引用，指向 **shared_ptr** 所管理的对象



这三个模板类都定义在 `<memory>` 头文件中。



最安全的使用动态内存的方法是调用一个库函数 **make_shared** 来返回一个对象的 **shared_ptr** 。

* **`make_shared()`**

    用法如下：

    ```c++
    shared_ptr<int> p1 = make_shared<int>(10);
    shared_ptr<string> p2 = make_shared<string>(5,'9');  // p2 指向 "99999"
    auto p3 = make_shared<vector<int>>();      // 推荐使用自动推导类型
    ```



> 怎样实现自动释放动态对象？

借助的是一个 shared_ptr 自带的**引用计数**器。

无论何时，拷贝一个 shared_ptr 都会使计数器递增，这种拷贝涉及到以下几种情况：

1. 用一个 shared_ptr 初始化另一个 shared_ptr；
2. 将一个 shared_ptr 作为参数传递给函数；
3. shared_ptr 作为函数的返回值；

当 shared_prt 被赋予新的值或被销毁（局部的shared_ptr离开作用域），计数器就会递减。一旦计数器减少到 0 ，它就会自动释放自己管理的对象。



```c++
auto p = make_shared<int>(42);
auto q(p);    // 用一个 shared_ptr 初始化另一个 shared_ptr

auto r = make_shared<int>(42);
r = q;        // 递增 q 指向的对象的引用计数，递减 r 原来指向的对象的引用计数