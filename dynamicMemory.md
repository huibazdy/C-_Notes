# 动态内存

## 对象的生命周期

* 全局对象
* 自动对象
* static对象
* 动态分配的对象

动态分配的对象生命周期与它们在哪被创建无关，只有被显示释放时，才会被销毁。

动态对象的正确释放是极易出错的。

为了更安全地使用动态对象，标准库定义了***两个智能指针类型***来管理动态分配的对象。当一个动态对象应该被释放时，指向它的智能指针可以确保自动释放它。

## 内存模型

### 静态内存

用来保存以下几类数据：

* 定义在任何函数之外的变量
* 局部static对象
* 类的static数据成员

> 分配在静态内存中的对象由编译器自动创建和销毁



### 栈内存

* 定义在函数内的非static对象（仅在定义的程序块运行时才存在）

> 分配在栈内存中的对象也由编译器自动创建和销毁



### 堆内存

每个程序除了有静态内存和栈内存，还拥有一个***内存池***，这部分内存也被称作***自由空间（free store）***或***堆（heap）***。

程序用堆来存储***动态分配（dynamically allocate）***的对象，换句话说就是哪些在程序***运行时分配***的对象。

动态对象的生命周期由程序控制，也就是当动态对象不再使用时，代码***必须显式销毁***它们。



## 动态内存管理

动态内存是由一对运算符来完成的：

* `new`：在动态内存中为对象分配空间，并返回一个指向该对象的指针，可以选择对对象初始化
* `delete`：接收一个动态对象的指针，销毁该对象，并释放与之关联的内存



确保在正确的时间释放动态内存是很困难的。有时忘记释放，就会产生***内存泄漏***。

有时尚有指针引用内存的情况，不该释放缺释放了，会产生***引用非法内存的指针***。



为了避免出现以上两种常见错误，新标准库提供了两种***智能指针（smart pointer）***来管理动态对象：

* `shared_ptr`：允许多个指针指向同一个对象
* `unique_ptr`：“独占”所指向的对象
* `weak_ptr`：伴随类，是一种弱引用，指向shared_ptr所管理的对象

类似于常规指针，区别是智能指针负责***自动释放所指向的对象***。这三种类型都定义在`<memory>`头文件中。



## 智能指针

### shared_ptr

类似于vector，shared_ptr也是模板类，需要提供额外信息（指针可以指向的类型）

```c++
#include<memory>
#include<list>
#include<string>

shared_ptr<string> p1;         //可以指向string
shared_ptr<list<int>> p2;      //可以指向int的list
```

==TODO==



## 直接管理内存