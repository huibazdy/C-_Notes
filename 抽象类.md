## 抽象类

> **带有纯虚函数的类为抽象类**

在面向对象编程方式中，抽象类是一种**只能定义但不能实例化**的类。例如“形状”就是典型的抽象类（还有“动物”...等都是抽象类），本身是不能实例化的。“形状”具有数据成员：边长、面积...；也有成员函数：求面积、求周长...

我们可以定义一个“形状”基类来对具体形状（如三角形、矩形、圆等）进行抽象，再让具体形状来继承这个基类。

```C++
/*定义形状基类*/
class Shape
{
    public:
        double area(){ //求面积
            //不知道实际形状无法计算
        }
};
```

对于“形状”这个类来说，`area()`函数是无法实现的。另一方面需要将它标识为抽象类以达到使其不能实例化的目的（因为实例化毫无意义）。

**C++**本身是没有抽象类的概念的，它借助**纯虚函数**（只定义函数原型的成员函数）来实现抽象类（C++规定类中只要包含纯虚函数，该类就变成一个**抽象类**）。所以需要将`area()`函数声明为一个纯虚函数：

```C++
virtual double area() = 0;
//virtual声明是虚函数，加上“=0”表明是纯虚函数，不需要函数体，即纯虚函数不被实现
```



抽象类不能实例化对象，只能用作父类被继承，且派生出的子类必须重写并实现纯虚函数（**多态性：通过基类访问派生类定义的函数**）。

在子类中，父类的**纯虚函数被实现后就变为虚函数**。

若派生类没有实现基类的纯虚函数，那么派生类依然是抽象类。



## 继承

圆形继承“形状”类

```C++
class Circle:public Shape
{
    private:
        int  r;
    public:
        Circle(int a):r(a){}
        double area(){return r*r*3.14;}
};
```

矩形继承“形状”类

```C++
class Rectangle:public Shape
{
    private:
        int x;
        int y;
    public:
        Rectangle(int a,int b):x(a),y(b){}
        double area(){return x*y;}
};
```



## 接口

C++中的接口是一种**特殊的抽象类**，需要满足两个条件：

1. 类中没有定义任何数据成员
2. 类中所有成员函数都是公有的且都为纯虚函数

举例说明接口：

```C++
class Interface_example()
{
    public:
        virtual bool openDev() = 0;
        virtual int readDev(char* buf,int len) = 0;
};
```

